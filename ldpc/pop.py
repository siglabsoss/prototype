"""Module docstring.This serves as a long usage message."""import sysimport getoptimport subprocessimport randomimport oskeybase = 'testkey'def keyname():    return keybase+'.pchk'def genname():    return keybase+'.gen'def filebase(length):    filebasen = 'testfile'    return filebasen + '_kval_' + str(length);def encodedFileName(length):    return filebase(length)+'.encoded'def rawFileName(length):    return filebase(length)+'.raw'def receivedFileName(length):    return filebase(length)+'.received'def extractedFileName(length):    return filebase(length)+'.extracted'def decodedFileName(length):    return filebase(length)+'.decoded'def pickRand():    return random.randint(0,10000);def genLdpc(klen, length, random, ones):    argList = [keyname(), length-klen, length, random, 'evencol', ones, 'no4cycle'];    # argList = [keyname(), length-klen, length, random, 'evencol', '0.3x2/0.6x' + str(ones) + '/0.1x7', 'no4cycle'];    args = ' '.join([str(x) for x in argList])    os.system('./make-ldpc ' + args)def makeGen():    argList = [keyname(), genname(), 'sparse'];    args = ' '.join([str(x) for x in argList])    os.system('./make-gen ' + args)def encode(klen, length):    print 'Encoding file with name: ' + rawFileName(klen)    argList = [keyname(), genname(), rawFileName(klen), encodedFileName(klen)];    args = ' '.join([str(x) for x in argList])    os.system('./encode ' + args)def transmit(klen, length, random, noise):    argList = [encodedFileName(klen), receivedFileName(klen), random, 'bsc', noise];    args = ' '.join([str(x) for x in argList])    os.system('./transmit ' + args)def decode(klen, length, random, noise):    # Put '-t' as first param for verbose decoding    argList = [keyname(), receivedFileName(klen), decodedFileName(klen), 'bsc', noise, 'prprp', 1000];    args = ' '.join([str(x) for x in argList])    os.system('./decode ' + args)def verify(klen, length, random, noise):    #./verify -t testkey.pchk testfile_kval_24.decoded testkey.gen testfile_kval_24.encoded    argList = ['-t', keyname(), decodedFileName(klen), genname(), encodedFileName(klen)];    args = ' '.join([str(x) for x in argList])    output = os.popen('./verify ' + args + " | cut -d',' -f 2").read()    outputLines = output.split('\n')    # Remove first one    del outputLines[0]    # remove last one    outputLines.pop()    errorsFound = 0    resultsFound = 0    for errorCount in outputLines:        if errorCount != "0":            errorsFound += 1        resultsFound += 1    return [resultsFound, errorsFound]globalResults = []def runBatch(klen, length, random, ones, noise):    genLdpc(klen, length, random, ones)    makeGen()    encode(klen, length)    errorsFound = 0    resultsFound = 0    for iterations in range(0,10):        transmit(klen, length, pickRand(), noise)        decode(klen, length, random, noise)        [iterationResults, iterationErrors] = verify(klen, length, random, noise)        errorsFound += iterationErrors        resultsFound += iterationResults    print "After checking", resultsFound, "blocks there were", errorsFound, "transmitted in error"    global globalResults    globalResults.append([resultsFound, errorsFound, klen, length, ones, noise])def main():    # Run with a message length of k    k = 24    # Coded block size of n    n = 240    # Noise is a value from 0 to 1    noise = 0.2    # ones, How many ones are filled (per line?) of the generator matrix, very confusing how to choose this correctly    ones = 1    # Seed with the same    random.seed(42)    global globalResults    globalResults = []    for onesIterations in range(0,6):        for noiseIterations in range(0,10):            runBatch(k,                     n,                     pickRand(),                     ones + onesIterations,                     noise + float(noiseIterations*0.05) )    print ""    print ""    print ""    print ""    print "fail%, k, n, ones, noise"    for pi in range(0,len(globalResults)):        res = globalResults[pi]        # print "", res[1]/res[0], "hi"        print float(res[1])/res[0], ",", res[2], ",", res[3], ",", res[4], ",", res[5]    return    # parse command line options    try:        opts, args = getopt.getopt(sys.argv[1:], "h", ["help"])    except getopt.error, msg:        print msg        print "for help use --help"        sys.exit(2)    # process options    for o, a in opts:        if o in ("-h", "--help"):            print __doc__            sys.exit(0)    # process arguments    for arg in args:        process(arg)if __name__ == "__main__":    main()